/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.40 from the
 * contents of File.xs. Do not edit this file, edit File.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "File.xs"
/* Win32API/File.xs */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
/*#include "patchlevel.h"*/

/* Uncomment the next line unless set "WRITE_PERL=>1" in Makefile.PL: */
#define NEED_newCONSTSUB
#include "ppport.h"

#ifdef WORD
# undef WORD
#endif

#define  WIN32_LEAN_AND_MEAN	/* Tell windows.h to skip much */
#include <windows.h>
#include <winioctl.h>

/*CONSTS_DEFINED*/

#ifndef INVALID_SET_FILE_POINTER
#   define INVALID_SET_FILE_POINTER	((DWORD)-1)
#endif

#define oDWORD DWORD

#if (PERL_REVISION <= 5 && PERL_VERSION < 5) || defined(__CYGWIN__)
# define win32_get_osfhandle _get_osfhandle
# ifdef __CYGWIN__
#  define win32_open_osfhandle(handle,mode) \
	(Perl_croak(aTHX_ "_open_osfhandle not implemented on Cygwin!"), -1)
# else
#  define win32_open_osfhandle _open_osfhandle
# endif
# ifdef _get_osfhandle
#  undef _get_osfhandle	/* stolen_get_osfhandle() isn't available here */
# endif
# ifdef _open_osfhandle
#  undef _open_osfhandle /* stolen_open_osfhandle() isn't available here */
# endif
#endif

#ifndef XST_mUV
# define XST_mUV(i,v)  (ST(i) = sv_2mortal(newSVuv(v))  )
#endif

#ifndef XSRETURN_UV
# define XSRETURN_UV(v) STMT_START { XST_mUV(0,v);  XSRETURN(1); } STMT_END
#endif

#ifndef DEBUGGING
# define	Debug(list)	/*Nothing*/
#else
# define	Debug(list)	ErrPrintf list
# include <stdarg.h>
    static void
    ErrPrintf( const char *sFmt, ... )
    {
      va_list pAList;
      static char *sEnv= NULL;
      DWORD uErr= GetLastError();
	if(  NULL == sEnv  ) {
	    if(  NULL == ( sEnv= getenv("DEBUG_WIN32API_FILE") )  )
		sEnv= "";
	}
	if(  '\0' == *sEnv  )
	    return;
	va_start( pAList, sFmt );
	vfprintf( stderr, sFmt, pAList );
	va_end( pAList );
	SetLastError( uErr );
    }
#endif /* DEBUGGING */


#include "buffers.h"	/* Include this after DEBUGGING setup finished */

static LONG uLastFileErr= 0;

static void
SaveErr( BOOL bFailed )
{
    if(  bFailed  ) {
	uLastFileErr= GetLastError();
    }
}

#line 99 "File.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 243 "File.c"

XS_EUPXS(XS_Win32API__File__fileLastError); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File__fileLastError)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "uError=0");
    {
	DWORD	uError;
	LONG	RETVAL;

	if (items < 1)
	    uError = 0;
	else {
	    uError= null_arg(ST(0)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(0)))
;
	}
#line 98 "File.xs"
	if(  1 <= items  ) {
	    uLastFileErr= uError;
	}
	RETVAL= uLastFileErr;
#line 266 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setiv( RETVALSV, PTR2IV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_CloseHandle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_CloseHandle)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hObject");
    {
	HANDLE	hObject;
	BOOL	RETVAL;

	hObject= null_arg(ST(0)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(0)))
;
#line 110 "File.xs"
        RETVAL = CloseHandle( hObject );
	SaveErr( !RETVAL );
#line 294 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_CopyFileA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_CopyFileA)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "sOldFileName, sNewFileName, bFailIfExists");
    {
	char *	sOldFileName;
	char *	sNewFileName;
	BOOL	bFailIfExists;
	BOOL	RETVAL;

	if(  null_arg(ST(0))  )
	    sOldFileName= NULL;
	else
	    sOldFileName= (char *) SvPV_nolen( ST(0) )
;

	if(  null_arg(ST(1))  )
	    sNewFileName= NULL;
	else
	    sNewFileName= (char *) SvPV_nolen( ST(1) )
;

	bFailIfExists= null_arg(ST(2))||!SvTRUE(ST(2)) ? (BOOL)0 : looks_like_number(ST(2)) ? (BOOL)SvIV(ST(2)) : (BOOL)1
;
#line 122 "File.xs"
        RETVAL = CopyFileA( sOldFileName, sNewFileName, bFailIfExists );
	SaveErr( !RETVAL );
#line 341 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_CopyFileW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_CopyFileW)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "swOldFileName, swNewFileName, bFailIfExists");
    {
	WCHAR *	swOldFileName;
	WCHAR *	swNewFileName;
	BOOL	bFailIfExists;
	BOOL	RETVAL;

	if(  null_arg(ST(0))  )
	    swOldFileName= NULL;
	else
	    swOldFileName= (WCHAR *) SvPV_nolen( ST(0) )
;

	if(  null_arg(ST(1))  )
	    swNewFileName= NULL;
	else
	    swNewFileName= (WCHAR *) SvPV_nolen( ST(1) )
;

	bFailIfExists= null_arg(ST(2))||!SvTRUE(ST(2)) ? (BOOL)0 : looks_like_number(ST(2)) ? (BOOL)SvIV(ST(2)) : (BOOL)1
;
#line 134 "File.xs"
        RETVAL = CopyFileW( swOldFileName, swNewFileName, bFailIfExists );
	SaveErr( !RETVAL );
#line 388 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_CreateFileA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_CreateFileA)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "sPath, uAccess, uShare, pSecAttr, uCreate, uFlags, hModel");
    {
	char *	sPath;
	DWORD	uAccess;
	DWORD	uShare;
	void *	pSecAttr;
	DWORD	uCreate;
	DWORD	uFlags;
	HANDLE	hModel;
	HANDLE	RETVAL;

	if(  null_arg(ST(0))  )
	    sPath= NULL;
	else
	    sPath= (char *) SvPV_nolen( ST(0) )
;

	uAccess= null_arg(ST(1)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(1)))
;

	uShare= null_arg(ST(2)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(2)))
;

	if(  null_arg(ST(3))  )
	    pSecAttr= NULL;
	else
	    pSecAttr= (void *) SvPV_nolen( ST(3) )
;

	uCreate= null_arg(ST(4)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(4)))
;

	uFlags= null_arg(ST(5)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(5)))
;

	hModel= null_arg(ST(6)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(6)))
;
#line 150 "File.xs"
	RETVAL= CreateFileA( sPath, uAccess, uShare,
	  (LPSECURITY_ATTRIBUTES)pSecAttr, uCreate, uFlags, hModel );
	if(  INVALID_HANDLE_VALUE == RETVAL  ) {
	    SaveErr( 1 );
	    XSRETURN_NO;
	} else if(  0 == RETVAL  ) {
	    XSRETURN_PV( "0 but true" );
	} else {
	    XSRETURN_UV( PTR2UV(RETVAL) );
	}
#line 459 "File.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_CreateFileW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_CreateFileW)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "swPath, uAccess, uShare, pSecAttr, uCreate, uFlags, hModel");
    {
	WCHAR *	swPath;
	DWORD	uAccess;
	DWORD	uShare;
	void *	pSecAttr;
	DWORD	uCreate;
	DWORD	uFlags;
	HANDLE	hModel;
	HANDLE	RETVAL;

	if(  null_arg(ST(0))  )
	    swPath= NULL;
	else
	    swPath= (WCHAR *) SvPV_nolen( ST(0) )
;

	uAccess= null_arg(ST(1)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(1)))
;

	uShare= null_arg(ST(2)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(2)))
;

	if(  null_arg(ST(3))  )
	    pSecAttr= NULL;
	else
	    pSecAttr= (void *) SvPV_nolen( ST(3) )
;

	uCreate= null_arg(ST(4)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(4)))
;

	uFlags= null_arg(ST(5)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(5)))
;

	hModel= null_arg(ST(6)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(6)))
;
#line 172 "File.xs"
	RETVAL= CreateFileW( swPath, uAccess, uShare,
	  (LPSECURITY_ATTRIBUTES)pSecAttr, uCreate, uFlags, hModel );
	if(  INVALID_HANDLE_VALUE == RETVAL  ) {
	    SaveErr( 1 );
	    XSRETURN_NO;
	} else if(  0 == RETVAL  ) {
	    XSRETURN_PV( "0 but true" );
	} else {
	    XSRETURN_UV( PTR2UV(RETVAL) );
	}
#line 518 "File.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_DefineDosDeviceA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_DefineDosDeviceA)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "uFlags, sDosDeviceName, sTargetPath");
    {
	DWORD	uFlags;
	char *	sDosDeviceName;
	char *	sTargetPath;
	BOOL	RETVAL;

	uFlags= null_arg(ST(0)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(0)))
;

	if(  null_arg(ST(1))  )
	    sDosDeviceName= NULL;
	else
	    sDosDeviceName= (char *) SvPV_nolen( ST(1) )
;

	if(  null_arg(ST(2))  )
	    sTargetPath= NULL;
	else
	    sTargetPath= (char *) SvPV_nolen( ST(2) )
;
#line 190 "File.xs"
        RETVAL = DefineDosDeviceA( uFlags, sDosDeviceName, sTargetPath );
	SaveErr( !RETVAL );
#line 553 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_DefineDosDeviceW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_DefineDosDeviceW)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "uFlags, swDosDeviceName, swTargetPath");
    {
	DWORD	uFlags;
	WCHAR *	swDosDeviceName;
	WCHAR *	swTargetPath;
	BOOL	RETVAL;

	uFlags= null_arg(ST(0)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(0)))
;

	if(  null_arg(ST(1))  )
	    swDosDeviceName= NULL;
	else
	    swDosDeviceName= (WCHAR *) SvPV_nolen( ST(1) )
;

	if(  null_arg(ST(2))  )
	    swTargetPath= NULL;
	else
	    swTargetPath= (WCHAR *) SvPV_nolen( ST(2) )
;
#line 202 "File.xs"
        RETVAL = DefineDosDeviceW( uFlags, swDosDeviceName, swTargetPath );
	SaveErr( !RETVAL );
#line 600 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_DeleteFileA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_DeleteFileA)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sFileName");
    {
	char *	sFileName;
	BOOL	RETVAL;

	if(  null_arg(ST(0))  )
	    sFileName= NULL;
	else
	    sFileName= (char *) SvPV_nolen( ST(0) )
;
#line 212 "File.xs"
        RETVAL = DeleteFileA( sFileName );
	SaveErr( !RETVAL );
#line 636 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_DeleteFileW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_DeleteFileW)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "swFileName");
    {
	WCHAR *	swFileName;
	BOOL	RETVAL;

	if(  null_arg(ST(0))  )
	    swFileName= NULL;
	else
	    swFileName= (WCHAR *) SvPV_nolen( ST(0) )
;
#line 222 "File.xs"
        RETVAL = DeleteFileW( swFileName );
	SaveErr( !RETVAL );
#line 672 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_DeviceIoControl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_DeviceIoControl)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "hDevice, uIoControlCode, pInBuf, lInBuf, opOutBuf, lOutBuf, olRetBytes, pOverlapped");
    {
	HANDLE	hDevice;
	DWORD	uIoControlCode;
	char *	pInBuf;
	DWORD	lInBuf = init_buf_l(ST(3));
	char *	opOutBuf;
	DWORD	lOutBuf = init_buf_l(ST(5));
	oDWORD	olRetBytes;
	void *	pOverlapped;
	BOOL	RETVAL;

	hDevice= null_arg(ST(0)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(0)))
;

	uIoControlCode= null_arg(ST(1)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(1)))
;

	if(  null_arg(ST(2))  )
	    pInBuf= NULL;
	else
	    pInBuf= (char *) SvPV_nolen( ST(2) )
;

	olRetBytes= optUV(ST(6))
;

	if(  null_arg(ST(7))  )
	    pOverlapped= NULL;
	else
	    pOverlapped= (void *) SvPV_nolen( ST(7) )
;
#line 239 "File.xs"
	if(  NULL != pInBuf  ) {
	    if(  0 == lInBuf  ) {
		lInBuf= SvCUR(ST(2));
	    } else if(  SvCUR(ST(2)) < lInBuf  ) {
		croak( "%s: pInBuf shorter than specified (%d < %d)",
		  "Win32API::File::DeviceIoControl", SvCUR(ST(2)), lInBuf );
	    }
	}
	grow_buf_l( opOutBuf,ST(4),char *, lOutBuf,ST(5) );
	RETVAL= DeviceIoControl( hDevice, uIoControlCode, pInBuf, lInBuf,
		  opOutBuf, lOutBuf, &olRetBytes, (LPOVERLAPPED)pOverlapped );
	SaveErr( !RETVAL );
#line 740 "File.c"
	trunc_buf_l( RETVAL, opOutBuf,ST(4), olRetBytes );
	SvSETMAGIC(ST(4));
	if(  ! null_arg(ST(6))  )
	    sv_setuv( ST(6), PTR2UV(olRetBytes) );
	SvSETMAGIC(ST(6));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_FdGetOsFHandle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_FdGetOsFHandle)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ivFd");
    {
	int	ivFd;
	HANDLE	RETVAL;

	ivFd= null_arg(ST(0)) ? (int)0 : INT2PTR(int,SvIV(ST(0)))
;
#line 261 "File.xs"
	RETVAL= (HANDLE) win32_get_osfhandle( ivFd );
	SaveErr( INVALID_HANDLE_VALUE == RETVAL );
#line 778 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetDriveTypeA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetDriveTypeA)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sRootPath");
    {
	char *	sRootPath;
	DWORD	RETVAL;

	if(  null_arg(ST(0))  )
	    sRootPath= NULL;
	else
	    sRootPath= (char *) SvPV_nolen( ST(0) )
;
#line 271 "File.xs"
        RETVAL = GetDriveTypeA( sRootPath );
	SaveErr( !RETVAL );
#line 809 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetDriveTypeW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetDriveTypeW)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "swRootPath");
    {
	WCHAR *	swRootPath;
	DWORD	RETVAL;

	if(  null_arg(ST(0))  )
	    swRootPath= NULL;
	else
	    swRootPath= (WCHAR *) SvPV_nolen( ST(0) )
;
#line 281 "File.xs"
        RETVAL = GetDriveTypeW( swRootPath );
	SaveErr( !RETVAL );
#line 840 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetFileAttributesA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetFileAttributesA)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sPath");
    {
	char *	sPath;
	DWORD	RETVAL;

	if(  null_arg(ST(0))  )
	    sPath= NULL;
	else
	    sPath= (char *) SvPV_nolen( ST(0) )
;
#line 291 "File.xs"
        RETVAL = GetFileAttributesA( sPath );
	SaveErr( !RETVAL );
#line 871 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetFileAttributesW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetFileAttributesW)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "swPath");
    {
	WCHAR *	swPath;
	DWORD	RETVAL;

	if(  null_arg(ST(0))  )
	    swPath= NULL;
	else
	    swPath= (WCHAR *) SvPV_nolen( ST(0) )
;
#line 301 "File.xs"
        RETVAL = GetFileAttributesW( swPath );
	SaveErr( !RETVAL );
#line 902 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetFileType); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetFileType)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hFile");
    {
	HANDLE	hFile;
	DWORD	RETVAL;

	hFile= null_arg(ST(0)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(0)))
;
#line 311 "File.xs"
        RETVAL = GetFileType( hFile );
	SaveErr( !RETVAL );
#line 930 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetHandleInformation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetHandleInformation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "hObject, ouFlags");
    {
	HANDLE	hObject;
	oDWORD *	ouFlags;
	BOOL	RETVAL;

	hObject= null_arg(ST(0)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(0)))
;

	if(  null_arg(ST(1))  )
	    ouFlags= NULL;
	else
	    *( ouFlags= (oDWORD *) TempAlloc( sizeof(*(ouFlags)) ) )=
	      SvOK(ST(1)) ? SvUV(ST(1)) : 0
;
#line 322 "File.xs"
        RETVAL = GetHandleInformation( hObject, ouFlags );
	SaveErr( !RETVAL );
#line 966 "File.c"
	if(  ! null_arg(ST(1))  )
	    sv_setuv( ST(1), (UV)*(ouFlags) );
	SvSETMAGIC(ST(1));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetLogicalDrives); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetLogicalDrives)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	DWORD	RETVAL;
#line 332 "File.xs"
        RETVAL = GetLogicalDrives();
	SaveErr( !RETVAL );
#line 998 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetLogicalDriveStringsA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetLogicalDriveStringsA)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "lBufSize, osBuffer");
    {
	DWORD	lBufSize = init_buf_l(ST(0));
	char *	osBuffer;
	DWORD	RETVAL;
#line 343 "File.xs"
	grow_buf_l( osBuffer,ST(1),char *, lBufSize,ST(0) );
	RETVAL= GetLogicalDriveStringsA( lBufSize, osBuffer );
	if(  lBufSize < RETVAL  &&  autosize(ST(0))  ) {
	    lBufSize= RETVAL;
	    grow_buf_l( osBuffer,ST(1),char *, lBufSize,ST(0) );
	    RETVAL= GetLogicalDriveStringsA( lBufSize, osBuffer );
	}
	if(  0 == RETVAL  ||  lBufSize < RETVAL  ) {
	    SaveErr( 1 );
	} else {
	    trunc_buf_l( 1, osBuffer,ST(1), RETVAL );
	}
#line 1034 "File.c"
	;/* The code for this appears above. */
	SvSETMAGIC(ST(1));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetLogicalDriveStringsW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetLogicalDriveStringsW)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "lwBufSize, oswBuffer");
    {
	DWORD	lwBufSize = init_buf_lw(ST(0));
	WCHAR *	oswBuffer;
	DWORD	RETVAL;
#line 365 "File.xs"
	grow_buf_lw( oswBuffer,ST(1), lwBufSize,ST(0) );
	RETVAL= GetLogicalDriveStringsW( lwBufSize, oswBuffer );
	if(  lwBufSize < RETVAL  &&  autosize(ST(0))  ) {
	    lwBufSize= RETVAL;
	    grow_buf_lw( oswBuffer,ST(1), lwBufSize,ST(0) );
	    RETVAL= GetLogicalDriveStringsW( lwBufSize, oswBuffer );
	}
	if(  0 == RETVAL  ||  lwBufSize < RETVAL  ) {
	    SaveErr( 1 );
	} else {
	    trunc_buf_lw( 1, oswBuffer,ST(1), RETVAL );
	}
#line 1072 "File.c"
	;/* The code for this appears above. */
	SvSETMAGIC(ST(1));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetVolumeInformationA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetVolumeInformationA)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "sRootPath, osVolName, lVolName, ouSerialNum, ouMaxNameLen, ouFsFlags, osFsType, lFsType");
    {
	char *	sRootPath;
	char *	osVolName;
	DWORD	lVolName = init_buf_l(ST(2));
	oDWORD	ouSerialNum = optUV(ST(3));
	oDWORD	ouMaxNameLen = optUV(ST(4));
	oDWORD	ouFsFlags = optUV(ST(5));
	char *	osFsType;
	DWORD	lFsType = init_buf_l(ST(7));
	BOOL	RETVAL;

	if(  null_arg(ST(0))  )
	    sRootPath= NULL;
	else
	    sRootPath= (char *) SvPV_nolen( ST(0) )
;
#line 393 "File.xs"
	grow_buf_l( osVolName,ST(1),char *, lVolName,ST(2) );
	grow_buf_l( osFsType,ST(6),char *, lFsType,ST(7) );
	RETVAL= GetVolumeInformationA( sRootPath, osVolName, lVolName,
		  &ouSerialNum, &ouMaxNameLen, &ouFsFlags, osFsType, lFsType );
	SaveErr( !RETVAL );
#line 1115 "File.c"
	trunc_buf_z( RETVAL, osVolName,ST(1) );
	SvSETMAGIC(ST(1));
	trunc_buf_z( RETVAL, osFsType,ST(6) );
	SvSETMAGIC(ST(6));
	if(  ! null_arg(ST(3))  )
	    sv_setuv( ST(3), PTR2UV(ouSerialNum) );
	SvSETMAGIC(ST(3));
	if(  ! null_arg(ST(4))  )
	    sv_setuv( ST(4), PTR2UV(ouMaxNameLen) );
	SvSETMAGIC(ST(4));
	if(  ! null_arg(ST(5))  )
	    sv_setuv( ST(5), PTR2UV(ouFsFlags) );
	SvSETMAGIC(ST(5));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetVolumeInformationW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetVolumeInformationW)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "swRootPath, oswVolName, lwVolName, ouSerialNum, ouMaxNameLen, ouFsFlags, oswFsType, lwFsType");
    {
	WCHAR *	swRootPath;
	WCHAR *	oswVolName;
	DWORD	lwVolName = init_buf_lw(ST(2));
	oDWORD	ouSerialNum = optUV(ST(3));
	oDWORD	ouMaxNameLen = optUV(ST(4));
	oDWORD	ouFsFlags = optUV(ST(5));
	WCHAR *	oswFsType;
	DWORD	lwFsType = init_buf_lw(ST(7));
	BOOL	RETVAL;

	if(  null_arg(ST(0))  )
	    swRootPath= NULL;
	else
	    swRootPath= (WCHAR *) SvPV_nolen( ST(0) )
;
#line 418 "File.xs"
	grow_buf_lw( oswVolName,ST(1), lwVolName,ST(2) );
	grow_buf_lw( oswFsType,ST(6), lwFsType,ST(7) );
	RETVAL= GetVolumeInformationW( swRootPath, oswVolName, lwVolName,
	  &ouSerialNum, &ouMaxNameLen, &ouFsFlags, oswFsType, lwFsType );
	SaveErr( !RETVAL );
#line 1174 "File.c"
	trunc_buf_zw( RETVAL, oswVolName,ST(1) );
	SvSETMAGIC(ST(1));
	trunc_buf_zw( RETVAL, oswFsType,ST(6) );
	SvSETMAGIC(ST(6));
	if(  ! null_arg(ST(3))  )
	    sv_setuv( ST(3), PTR2UV(ouSerialNum) );
	SvSETMAGIC(ST(3));
	if(  ! null_arg(ST(4))  )
	    sv_setuv( ST(4), PTR2UV(ouMaxNameLen) );
	SvSETMAGIC(ST(4));
	if(  ! null_arg(ST(5))  )
	    sv_setuv( ST(5), PTR2UV(ouFsFlags) );
	SvSETMAGIC(ST(5));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_IsRecognizedPartition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_IsRecognizedPartition)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ivPartitionType");
    {
	int	ivPartitionType;
	BOOL	RETVAL;

	ivPartitionType= null_arg(ST(0)) ? (int)0 : INT2PTR(int,SvIV(ST(0)))
;
#line 436 "File.xs"
        RETVAL = IsRecognizedPartition( ivPartitionType );
	SaveErr( !RETVAL );
#line 1220 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_IsContainerPartition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_IsContainerPartition)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ivPartitionType");
    {
	int	ivPartitionType;
	BOOL	RETVAL;

	ivPartitionType= null_arg(ST(0)) ? (int)0 : INT2PTR(int,SvIV(ST(0)))
;
#line 446 "File.xs"
        RETVAL = IsContainerPartition( ivPartitionType );
	SaveErr( !RETVAL );
#line 1253 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_MoveFileA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_MoveFileA)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "sOldName, sNewName");
    {
	char *	sOldName;
	char *	sNewName;
	BOOL	RETVAL;

	if(  null_arg(ST(0))  )
	    sOldName= NULL;
	else
	    sOldName= (char *) SvPV_nolen( ST(0) )
;

	if(  null_arg(ST(1))  )
	    sNewName= NULL;
	else
	    sNewName= (char *) SvPV_nolen( ST(1) )
;
#line 457 "File.xs"
        RETVAL = MoveFileA( sOldName, sNewName );
	SaveErr( !RETVAL );
#line 1296 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_MoveFileW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_MoveFileW)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "swOldName, swNewName");
    {
	WCHAR *	swOldName;
	WCHAR *	swNewName;
	BOOL	RETVAL;

	if(  null_arg(ST(0))  )
	    swOldName= NULL;
	else
	    swOldName= (WCHAR *) SvPV_nolen( ST(0) )
;

	if(  null_arg(ST(1))  )
	    swNewName= NULL;
	else
	    swNewName= (WCHAR *) SvPV_nolen( ST(1) )
;
#line 468 "File.xs"
        RETVAL = MoveFileW( swOldName, swNewName );
	SaveErr( !RETVAL );
#line 1339 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_MoveFileExA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_MoveFileExA)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "sOldName, sNewName, uFlags");
    {
	char *	sOldName;
	char *	sNewName;
	DWORD	uFlags;
	BOOL	RETVAL;

	if(  null_arg(ST(0))  )
	    sOldName= NULL;
	else
	    sOldName= (char *) SvPV_nolen( ST(0) )
;

	if(  null_arg(ST(1))  )
	    sNewName= NULL;
	else
	    sNewName= (char *) SvPV_nolen( ST(1) )
;

	uFlags= null_arg(ST(2)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(2)))
;
#line 480 "File.xs"
        RETVAL = MoveFileExA( sOldName, sNewName, uFlags );
	SaveErr( !RETVAL );
#line 1386 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_MoveFileExW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_MoveFileExW)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "swOldName, swNewName, uFlags");
    {
	WCHAR *	swOldName;
	WCHAR *	swNewName;
	DWORD	uFlags;
	BOOL	RETVAL;

	if(  null_arg(ST(0))  )
	    swOldName= NULL;
	else
	    swOldName= (WCHAR *) SvPV_nolen( ST(0) )
;

	if(  null_arg(ST(1))  )
	    swNewName= NULL;
	else
	    swNewName= (WCHAR *) SvPV_nolen( ST(1) )
;

	uFlags= null_arg(ST(2)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(2)))
;
#line 492 "File.xs"
        RETVAL = MoveFileExW( swOldName, swNewName, uFlags );
	SaveErr( !RETVAL );
#line 1433 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_OsFHandleOpenFd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_OsFHandleOpenFd)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "hOsFHandle, uMode");
    {
	long	hOsFHandle;
	DWORD	uMode;
	long	RETVAL;

	hOsFHandle= null_arg(ST(0)) ? (long)0 : INT2PTR(long,SvIV(ST(0)))
;

	uMode= null_arg(ST(1)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(1)))
;
#line 503 "File.xs"
	RETVAL= win32_open_osfhandle( hOsFHandle, uMode );
	if(  RETVAL < 0  ) {
	    SaveErr( 1 );
	    XSRETURN_NO;
	} else if(  0 == RETVAL  ) {
	    XSRETURN_PV( "0 but true" );
	} else {
	    XSRETURN_IV( (IV) RETVAL );
	}
#line 1477 "File.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_QueryDosDeviceA); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_QueryDosDeviceA)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "sDeviceName, osTargetPath, lTargetBuf");
    {
	char *	sDeviceName;
	char *	osTargetPath;
	DWORD	lTargetBuf = init_buf_l(ST(2));
	DWORD	RETVAL;

	if(  null_arg(ST(0))  )
	    sDeviceName= NULL;
	else
	    sDeviceName= (char *) SvPV_nolen( ST(0) )
;
#line 520 "File.xs"
	grow_buf_l( osTargetPath,ST(1),char *, lTargetBuf,ST(2) );
	RETVAL= QueryDosDeviceA( sDeviceName, osTargetPath, lTargetBuf );
	SaveErr( 0 == RETVAL );
#line 1504 "File.c"
	trunc_buf_l( 1, osTargetPath,ST(1), RETVAL );
	SvSETMAGIC(ST(1));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_QueryDosDeviceW); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_QueryDosDeviceW)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "swDeviceName, oswTargetPath, lwTargetBuf");
    {
	WCHAR *	swDeviceName;
	WCHAR *	oswTargetPath;
	DWORD	lwTargetBuf = init_buf_lw(ST(2));
	DWORD	RETVAL;

	if(  null_arg(ST(0))  )
	    swDeviceName= NULL;
	else
	    swDeviceName= (WCHAR *) SvPV_nolen( ST(0) )
;
#line 534 "File.xs"
	grow_buf_lw( oswTargetPath,ST(1), lwTargetBuf,ST(2) );
	RETVAL= QueryDosDeviceW( swDeviceName, oswTargetPath, lwTargetBuf );
	SaveErr( 0 == RETVAL );
#line 1540 "File.c"
	trunc_buf_lw( 1, oswTargetPath,ST(1), RETVAL );
	SvSETMAGIC(ST(1));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_ReadFile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_ReadFile)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "hFile, opBuffer, lBytes, olBytesRead, pOverlapped");
    {
	HANDLE	hFile;
	BYTE *	opBuffer;
	DWORD	lBytes = init_buf_l(ST(2));
	oDWORD	olBytesRead;
	void *	pOverlapped;
	BOOL	RETVAL;

	hFile= null_arg(ST(0)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(0)))
;

	olBytesRead= optUV(ST(3))
;

	if(  null_arg(ST(4))  )
	    pOverlapped= NULL;
	else
	    pOverlapped= (void *) SvPV_nolen( ST(4) )
;
#line 550 "File.xs"
	grow_buf_l( opBuffer,ST(1),BYTE *, lBytes,ST(2) );
	/* Don't read more bytes than asked for if buffer is already big: */
	lBytes= init_buf_l(ST(2));
	if(  0 == lBytes  &&  autosize(ST(2))  ) {
	    lBytes= SvLEN( ST(1) ) - 1;
	}
	RETVAL= ReadFile( hFile, opBuffer, lBytes, &olBytesRead,
		  (LPOVERLAPPED)pOverlapped );
	SaveErr( !RETVAL );
#line 1590 "File.c"
	trunc_buf_l( RETVAL, opBuffer,ST(1), olBytesRead );
	SvSETMAGIC(ST(1));
	if(  ! null_arg(ST(3))  )
	    sv_setuv( ST(3), PTR2UV(olBytesRead) );
	SvSETMAGIC(ST(3));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetOverlappedResult); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetOverlappedResult)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait");
    {
	HANDLE	hFile;
	LPOVERLAPPED	lpOverlapped;
	LPDWORD	lpNumberOfBytesTransferred;
	BOOL	bWait;
	BOOL	RETVAL;

	hFile= null_arg(ST(0)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(0)))
;

	if(  null_arg(ST(1))  )
	    lpOverlapped= NULL;
	else
	    lpOverlapped= (LPOVERLAPPED) SvPV_nolen( ST(1) )
;

	if(  null_arg(ST(2))  )
	    lpNumberOfBytesTransferred= NULL;
	else
	    *( lpNumberOfBytesTransferred= (LPDWORD) TempAlloc( sizeof(*(lpNumberOfBytesTransferred)) ) )= SvUV(ST(2))
;

	bWait= null_arg(ST(3))||!SvTRUE(ST(3)) ? (BOOL)0 : looks_like_number(ST(3)) ? (BOOL)SvIV(ST(3)) : (BOOL)1
;
#line 572 "File.xs"
    	RETVAL= GetOverlappedResult( hFile, lpOverlapped,
	 lpNumberOfBytesTransferred, bWait);
	SaveErr( !RETVAL );
#line 1647 "File.c"
	;
	SvSETMAGIC(ST(1));
	if(  ! null_arg(ST(2))  &&  ! SvREADONLY(ST(2))  )
	    sv_setuv( ST(2), (UV)*(lpNumberOfBytesTransferred) );
	SvSETMAGIC(ST(2));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetFileSize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetFileSize)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "hFile, lpFileSizeHigh");
    {
	HANDLE	hFile;
	LPDWORD	lpFileSizeHigh;
	DWORD	RETVAL;

	hFile= null_arg(ST(0)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(0)))
;

	if(  null_arg(ST(1))  )
	    lpFileSizeHigh= NULL;
	else
	    *( lpFileSizeHigh= (LPDWORD) TempAlloc( sizeof(*(lpFileSizeHigh)) ) )= SvUV(ST(1))
;
#line 585 "File.xs"
    	RETVAL= GetFileSize( hFile, lpFileSizeHigh );
	SaveErr( NO_ERROR != GetLastError() );
#line 1692 "File.c"
	if(  ! null_arg(ST(1))  &&  ! SvREADONLY(ST(1))  )
	    sv_setuv( ST(1), (UV)*(lpFileSizeHigh) );
	SvSETMAGIC(ST(1));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_SetErrorMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_SetErrorMode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "uNewMode");
    {
	UINT	uNewMode;
	UINT	RETVAL;

	uNewMode= null_arg(ST(0)) ? (UINT)0 : INT2PTR(UINT,SvUV(ST(0)))
;

	RETVAL = SetErrorMode(uNewMode);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  )
		sv_setuv( RETVALSV, PTR2UV(RETVAL) );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_SetFilePointer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_SetFilePointer)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "hFile, ivOffset, ioivOffsetHigh, uFromWhere");
    {
	HANDLE	hFile;
	LONG	ivOffset;
	LONG *	ioivOffsetHigh;
	DWORD	uFromWhere;
	LONG	RETVAL;

	hFile= null_arg(ST(0)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(0)))
;

	ivOffset= null_arg(ST(1)) ? (LONG)0 : INT2PTR(LONG,SvIV(ST(1)))
;

	if(  null_arg(ST(2))  )
	    ioivOffsetHigh= NULL;
	else
	    *( ioivOffsetHigh= (LONG *) TempAlloc( sizeof(*(ioivOffsetHigh)) ) )= SvIV(ST(2))
;

	uFromWhere= null_arg(ST(3)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(3)))
;
#line 603 "File.xs"
	RETVAL= SetFilePointer( hFile, ivOffset, ioivOffsetHigh, uFromWhere );
	if(  RETVAL == INVALID_SET_FILE_POINTER && (GetLastError() != NO_ERROR)  ) {
	    SaveErr( 1 );
	    XST_mNO(0);
	} else if(  0 == RETVAL  ) {
	    XST_mPV(0,"0 but true");
	} else {
	    XST_mIV(0,RETVAL);
	}
#line 1771 "File.c"
	if(  ! null_arg(ST(2))  &&  ! SvREADONLY(ST(2))  )
	    sv_setiv( ST(2), (IV)*(ioivOffsetHigh) );
	SvSETMAGIC(ST(2));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_SetHandleInformation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_SetHandleInformation)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "hObject, uMask, uFlags");
    {
	HANDLE	hObject;
	DWORD	uMask;
	DWORD	uFlags;
	BOOL	RETVAL;

	hObject= null_arg(ST(0)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(0)))
;

	uMask= null_arg(ST(1)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(1)))
;

	uFlags= null_arg(ST(2)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(2)))
;
#line 622 "File.xs"
        RETVAL = SetHandleInformation( hObject, uMask, uFlags );
	SaveErr( !RETVAL );
#line 1803 "File.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_WriteFile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_WriteFile)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "hFile, pBuffer, lBytes, ouBytesWritten, pOverlapped");
    {
	HANDLE	hFile;
	BYTE *	pBuffer;
	DWORD	lBytes = init_buf_l(ST(2));
	oDWORD	ouBytesWritten;
	void *	pOverlapped;
	BOOL	RETVAL;

	hFile= null_arg(ST(0)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(0)))
;

	if(  null_arg(ST(1))  )
	    pBuffer= NULL;
	else
	    pBuffer= (BYTE *) SvPV_nolen( ST(1) )
;

	ouBytesWritten= optUV(ST(3))
;

	if(  null_arg(ST(4))  )
	    pOverlapped= NULL;
	else
	    pOverlapped= (void *) SvPV_nolen( ST(4) )
;
#line 636 "File.xs"
	/* SvCUR(ST(1)) might "panic" if pBuffer isn't valid */
	if(  0 == lBytes  ) {
	    lBytes= SvCUR(ST(1));
	} else if(  SvCUR(ST(1)) < lBytes  ) {
	    croak( "%s: pBuffer value too short (%d < %d)",
	      "Win32API::File::WriteFile", SvCUR(ST(1)), lBytes );
	}
	RETVAL= WriteFile( hFile, pBuffer, lBytes,
		  &ouBytesWritten, (LPOVERLAPPED)pOverlapped );
	SaveErr( !RETVAL );
#line 1863 "File.c"
	if(  ! null_arg(ST(3))  )
	    sv_setuv( ST(3), PTR2UV(ouBytesWritten) );
	SvSETMAGIC(ST(3));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if(  ! null_arg(RETVALSV)  &&  ! SvREADONLY(RETVALSV)  ) {
		if(  RETVAL  ) {
		    sv_setiv( RETVALSV, (IV)RETVAL );
		} else {
		    sv_setsv( RETVALSV, &PL_sv_no );
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32API__File_GetStdHandle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_GetStdHandle)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fd");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DWORD	fd;

	fd= null_arg(ST(0)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(0)))
;
#line 654 "File.xs"
#ifdef _WIN64
    XSRETURN_IV((DWORD_PTR)GetStdHandle(fd));
#else
    XSRETURN_IV((DWORD)GetStdHandle(fd));
#endif
#line 1903 "File.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32API__File_SetStdHandle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32API__File_SetStdHandle)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fd, handle");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DWORD	fd;
	HANDLE	handle;

	fd= null_arg(ST(0)) ? (DWORD)0 : INT2PTR(DWORD,SvUV(ST(0)))
;

	handle= null_arg(ST(1)) ? (HANDLE)0 : INT2PTR(HANDLE,SvUV(ST(1)))
;
#line 665 "File.xs"
    if (SetStdHandle(fd, handle))
	XSRETURN_YES;
    else
	XSRETURN_NO;
#line 1932 "File.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Win32API__File); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Win32API__File)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Win32API::File::_fileLastError", XS_Win32API__File__fileLastError);
        newXS_deffile("Win32API::File::CloseHandle", XS_Win32API__File_CloseHandle);
        newXS_deffile("Win32API::File::CopyFileA", XS_Win32API__File_CopyFileA);
        newXS_deffile("Win32API::File::CopyFileW", XS_Win32API__File_CopyFileW);
        newXS_deffile("Win32API::File::CreateFileA", XS_Win32API__File_CreateFileA);
        newXS_deffile("Win32API::File::CreateFileW", XS_Win32API__File_CreateFileW);
        newXS_deffile("Win32API::File::DefineDosDeviceA", XS_Win32API__File_DefineDosDeviceA);
        newXS_deffile("Win32API::File::DefineDosDeviceW", XS_Win32API__File_DefineDosDeviceW);
        newXS_deffile("Win32API::File::DeleteFileA", XS_Win32API__File_DeleteFileA);
        newXS_deffile("Win32API::File::DeleteFileW", XS_Win32API__File_DeleteFileW);
        newXS_deffile("Win32API::File::DeviceIoControl", XS_Win32API__File_DeviceIoControl);
        newXS_deffile("Win32API::File::FdGetOsFHandle", XS_Win32API__File_FdGetOsFHandle);
        newXS_deffile("Win32API::File::GetDriveTypeA", XS_Win32API__File_GetDriveTypeA);
        newXS_deffile("Win32API::File::GetDriveTypeW", XS_Win32API__File_GetDriveTypeW);
        newXS_deffile("Win32API::File::GetFileAttributesA", XS_Win32API__File_GetFileAttributesA);
        newXS_deffile("Win32API::File::GetFileAttributesW", XS_Win32API__File_GetFileAttributesW);
        newXS_deffile("Win32API::File::GetFileType", XS_Win32API__File_GetFileType);
        newXS_deffile("Win32API::File::GetHandleInformation", XS_Win32API__File_GetHandleInformation);
        newXS_deffile("Win32API::File::GetLogicalDrives", XS_Win32API__File_GetLogicalDrives);
        newXS_deffile("Win32API::File::GetLogicalDriveStringsA", XS_Win32API__File_GetLogicalDriveStringsA);
        newXS_deffile("Win32API::File::GetLogicalDriveStringsW", XS_Win32API__File_GetLogicalDriveStringsW);
        newXS_deffile("Win32API::File::GetVolumeInformationA", XS_Win32API__File_GetVolumeInformationA);
        newXS_deffile("Win32API::File::GetVolumeInformationW", XS_Win32API__File_GetVolumeInformationW);
        newXS_deffile("Win32API::File::IsRecognizedPartition", XS_Win32API__File_IsRecognizedPartition);
        newXS_deffile("Win32API::File::IsContainerPartition", XS_Win32API__File_IsContainerPartition);
        newXS_deffile("Win32API::File::MoveFileA", XS_Win32API__File_MoveFileA);
        newXS_deffile("Win32API::File::MoveFileW", XS_Win32API__File_MoveFileW);
        newXS_deffile("Win32API::File::MoveFileExA", XS_Win32API__File_MoveFileExA);
        newXS_deffile("Win32API::File::MoveFileExW", XS_Win32API__File_MoveFileExW);
        newXS_deffile("Win32API::File::OsFHandleOpenFd", XS_Win32API__File_OsFHandleOpenFd);
        newXS_deffile("Win32API::File::QueryDosDeviceA", XS_Win32API__File_QueryDosDeviceA);
        newXS_deffile("Win32API::File::QueryDosDeviceW", XS_Win32API__File_QueryDosDeviceW);
        newXS_deffile("Win32API::File::ReadFile", XS_Win32API__File_ReadFile);
        newXS_deffile("Win32API::File::GetOverlappedResult", XS_Win32API__File_GetOverlappedResult);
        newXS_deffile("Win32API::File::GetFileSize", XS_Win32API__File_GetFileSize);
        newXS_deffile("Win32API::File::SetErrorMode", XS_Win32API__File_SetErrorMode);
        newXS_deffile("Win32API::File::SetFilePointer", XS_Win32API__File_SetFilePointer);
        newXS_deffile("Win32API::File::SetHandleInformation", XS_Win32API__File_SetHandleInformation);
        newXS_deffile("Win32API::File::WriteFile", XS_Win32API__File_WriteFile);
        newXS_deffile("Win32API::File::GetStdHandle", XS_Win32API__File_GetStdHandle);
        newXS_deffile("Win32API::File::SetStdHandle", XS_Win32API__File_SetStdHandle);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

